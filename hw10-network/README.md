### 坦克大战网络版

* 建议运行分辨率：1280*720 Windowed
* 双人模式联机游戏
* 服务器作为player1控制右下角红色坦克，客户端作为player2控制左上角蓝色坦克，wasd移动，空格射击
* 射击有冷却时间
* 摧毁对方基地胜利，坦克被击中后会在基地边复活

### unity网络模块unet

unet是unity内置的网络模块，通过物体的网络组件和c#中的网络操作实现网络游戏和通信。unet的核心是networkmanager，管理所有网络组件和加载，通过给预制添加不同的网络组件可以实现不同的网络功能。

networkmanager设置里面的playerobject就是默认的player，它作为服务器默认的玩家预制，可以让服务器和客户端在每次连接到网络时都可以初始化设定的playerobject；spawnlist中的预制可以在场景中另外生成；每一个加入网络的预制都需要挂载networkidenty组件，作为它们在网络中的身份，挂载networktransform并且设定数值可以让它们的位置在网络中进行同步。

有了这些基础知识，就可以开始把之前的坦克大战转换成网络游戏了。

### firstcontroller作为playerobject

在原先的坦克大战基础上，首先去掉ai部分，网路游戏是玩家vs玩家；场景组建不用修改，需要在网络中生成的就是塔克、基地、子弹和碰撞逻辑。

我最初的设想是直接把firstcontroller作为playerobject，这样把场记作为player，不就在每个玩家开始游戏都分配一个场记，这样所有发生的事件都通过场记进行通信和处理，逻辑简单，代码整洁。

但是问题出现了，我无法通过spawn的方法产生和playerobject相同的网络对象，playerobject初始化的对象可以通过isserver和islocal判断是服务器还是客户端，即区分两个玩家，但是这两个方法对于spawn出来的对象没有用，所以我虽然在场记中可以区分两个玩家，但是场记spawn方法产生的坦克、基地都无法进行区分。

我认为的原因是unet的spawn都是服务器权限的对象，和playerobject不同，这样我就无法手动实现playerobject设为场记，只能放弃，改为坦克作为playerobject，再把所有逻辑放在坦克上。unet这个playerobject只能设定一个的规定让人无法理解，其实也可以通过改源码实现，我没有做。

### tank作为playerobject

因为playerobject可以判断不同玩家，所以坦克就有了不同的身份、位置，这样通过islocal也能实现每个玩家分别控制一个坦克。

playerobject在每次创建选择round robin轮转方法，场景中新建两个挂在networkstartposition的物体作为初始位置，这样两个坦克在产生时就有不同的位置。

Cmd操作是客户端发送的具有服务器权限的操作，里面通过spawn方法生产网络对象并对所有网络连接产生这个对象，这些对象在随意一处销毁就都会被销毁，这个正好作为子弹的生产方法。

rpc操作具有本地权限，这中函数可以在别处调用来修改本地对象，在本次用于塔克被击中后在基地边重生的位置修改。

SyncVar是服务器权限变量，在所有网络服务器和客户端的值都相同，这个用于同步游戏的进行状态，即哪个玩家胜利了这样的统一信息，usergui通过这个变量显示不同的信息，但是一个问题是command应该能修改所有的这种变量，但是实际上只有服务器才可以修改。

Syncvar参考https://blog.csdn.net/yangxuan0261/article/details/52555167

最终，场景中的逻辑全都通过碰撞实现，子弹的碰撞collision得到的gameobject用以对击中的玩家和基地进行对应操作。




